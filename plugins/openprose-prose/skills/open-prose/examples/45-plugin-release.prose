# Complete Plugin Release
# A thorough release process that does more than we'd do manually

input release_type: "Optional: 'major', 'minor', 'patch', or empty for auto-detect"

agent validator:
  model: sonnet
  prompt: "Validate code and documentation. Report issues clearly."
  permissions:
    read: ["**/*.prose", "**/*.md"]

agent analyzer:
  model: opus
  prompt: "Analyze git history and determine release impact."
  permissions:
    bash: allow

agent writer:
  model: opus
  prompt: "Write clear, concise release documentation."

agent executor:
  model: sonnet
  permissions:
    bash: allow
    write: ["**/*.json", "**/*.md"]

# ============================================================
# Phase 1: Pre-flight checks (parallel - fail fast)
# ============================================================

parallel (on-fail: "fail-fast"):
  examples_valid = session: validator
    prompt: "Compile all .prose examples, report any syntax errors"
    context: "skills/open-prose/examples/*.prose"

  docs_complete = session: validator
    prompt: "Verify README.md lists all example files that exist"
    context: "skills/open-prose/examples/"

  repo_clean = session: executor
    prompt: "Check for uncommitted changes, correct branch"

  no_duplicate = session: executor
    prompt: "List existing version tags"

if **pre-flight issues found**:
  throw "Pre-flight failed - fix issues before release"

# ============================================================
# Phase 2: Analyze what's being released
# ============================================================

let last_tag = session: executor
  prompt: "Get most recent version tag"

let commits = session: analyzer
  prompt: "Get all commits since last release"
  context: last_tag

let impact = session: analyzer
  prompt: """
    Analyze these commits. Categorize:
    - Breaking changes (API/contract changes)
    - Features (new capabilities)
    - Fixes (bug fixes, docs, refactors)
  """
  context: commits

# ============================================================
# Phase 3: Determine version
# ============================================================

let version = session: analyzer
  prompt: """
    Determine next version number.

    Current: {last_tag}
    Requested: {release_type}

    Rules:
    - Breaking changes → major bump
    - New features → minor bump
    - Fixes only → patch bump
    - If release_type specified, use it (but warn if it contradicts impact)
  """
  context: impact

if **version seems wrong for changes**:
  input user_override: "Confirm version {version} is correct"

# ============================================================
# Phase 4: Generate release artifacts (parallel)
# ============================================================

parallel:
  changelog_entry = session: writer
    prompt: "Write CHANGELOG entry for this release"
    context: { version, impact, commits }

  release_notes = session: writer
    prompt: "Write GitHub Release notes - concise, user-focused"
    context: { version, impact }

  commit_msg = session: writer
    prompt: "Write commit message"
    context: { version, impact }

# ============================================================
# Phase 5: Execute release
# ============================================================

try:
  # Update files
  let files_updated = session: executor
    prompt: "Update plugin.json to {version}"

  # Submodule release
  let committed = session: executor
    prompt: "Stage all, commit, tag v{version}, push with tags"
    context: { files_updated, commit_msg }

  # Parent repo
  let parent_done = session: executor
    prompt: "Update parent repo submodule reference, commit, push"
    context: committed

catch as err:
  session: executor
    prompt: "Rollback: delete local tag if created, reset commits"
    context: err
  throw "Release failed - rolled back"

# ============================================================
# Phase 6: Post-release (parallel)
# ============================================================

parallel (on-fail: "continue"):
  gh_release = session: executor
    prompt: "Create GitHub Release for v{version}"
    context: release_notes

  verified = session: executor
    prompt: "Pull marketplace, verify plugin.json shows {version}"

  install_test = session: validator
    prompt: "Test fresh plugin installation works"

# ============================================================
# Output
# ============================================================

output release = {
  version: version,
  tag: "v{version}",
  changelog: changelog_entry,
  notes: release_notes,
  verification: verified
}
