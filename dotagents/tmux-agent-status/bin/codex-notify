#!/usr/bin/env python3
"""
Codex notification handler for agent-status integration (PID-keyed).

State file structure:
{
  "agents": {
    "<pid>": {
      "session": "tmux-session-name",
      "pane": "%42",
      "agent": "codex",
      "state": "waiting|working",
      "timestamp": 1234567890
    }
  }
}
"""

import json
import os
import sys
import tempfile
import subprocess
import time

STATE_FILE = os.path.expanduser("~/.config/agents/state.json")
LOG_FILE = os.path.expanduser("~/.config/agents/notify.log")

WAITING_EVENT_TYPES = {
    "agent-turn-complete",
    "agent_turn_complete",
    "turn/completed",
    "turn_completed",
}

WORKING_EVENT_TYPES = {
    "agent-turn-start",
    "agent_turn_start",
    "turn/started",
    "turn_started",
}


def log(msg: str) -> None:
    """Log a message for debugging."""
    with open(LOG_FILE, "a") as f:
        f.write(f"{time.strftime('%H:%M:%S')} - {msg}\n")


def get_tmux_info() -> tuple[str | None, str | None]:
    """Get current tmux session name and pane ID."""
    session = None
    pane = None
    
    try:
        result = subprocess.run(
            ["tmux", "display-message", "-p", "#S\n#{pane_id}"],
            capture_output=True,
            text=True,
            timeout=1,
        )
        if result.returncode == 0:
            lines = result.stdout.strip().split("\n")
            session = lines[0] if len(lines) > 0 else None
            pane = lines[1] if len(lines) > 1 else None
    except Exception as e:
        log(f"Error getting tmux info: {e}")
    
    log(f"Tmux info: session={session}, pane={pane}")
    return session, pane


def get_codex_pid() -> int | None:
    """Find the codex process that spawned this notify script."""
    try:
        ppid = os.getppid()
        for _ in range(5):
            result = subprocess.run(
                ["ps", "-p", str(ppid), "-o", "comm="],
                capture_output=True,
                text=True,
                timeout=1,
            )
            comm = result.stdout.strip()
            if "codex" in comm.lower():
                return ppid
            result = subprocess.run(
                ["ps", "-p", str(ppid), "-o", "ppid="],
                capture_output=True,
                text=True,
                timeout=1,
            )
            ppid = int(result.stdout.strip())
    except Exception:
        pass
    return None


def read_state_file() -> dict:
    try:
        with open(STATE_FILE, "r") as f:
            data = json.load(f)
            # Migrate from old format if needed
            if "sessions" in data and "agents" not in data:
                return {"agents": {}}
            return data
    except (FileNotFoundError, json.JSONDecodeError):
        return {"agents": {}}


def write_state_file(state: dict) -> None:
    os.makedirs(os.path.dirname(STATE_FILE), exist_ok=True)
    fd, temp_path = tempfile.mkstemp(dir=os.path.dirname(STATE_FILE))
    try:
        with os.fdopen(fd, "w") as f:
            json.dump(state, f, indent=2)
        os.rename(temp_path, STATE_FILE)
    except Exception:
        os.unlink(temp_path)
        raise


def update_state(pid: int, session: str, pane: str | None, new_state: str) -> None:
    """Update state keyed by PID."""
    state = read_state_file()
    
    if "agents" not in state:
        state["agents"] = {}
    
    state["agents"][str(pid)] = {
        "session": session,
        "pane": pane,
        "agent": "codex",
        "state": new_state,
        "timestamp": int(time.time() * 1000),
    }
    
    write_state_file(state)
    log(f"Updated state: pid={pid} session={session} pane={pane} -> {new_state}")


def read_notification_payload() -> tuple[str | None, str]:
    """Read JSON payload from argv or stdin."""
    if len(sys.argv) >= 2:
        return sys.argv[1], "argv"
    if not sys.stdin.isatty():
        data = sys.stdin.read().strip()
        return (data or None), "stdin"
    return None, "none"


def extract_event_type(notification: dict) -> str:
    event_type = notification.get("type") or notification.get("method") or ""
    if not event_type and isinstance(notification.get("event"), dict):
        event_type = (
            notification.get("event", {}).get("type")
            or notification.get("event", {}).get("method")
            or ""
        )
    return event_type


def main() -> int:
    log(f"Called with args: {sys.argv}")

    payload, source = read_notification_payload()
    log(f"Payload source: {source}")
    if not payload:
        log("No payload provided")
        return 0

    try:
        notification = json.loads(payload)
        log(f"Parsed notification keys: {list(notification.keys())}")
    except json.JSONDecodeError as e:
        preview = payload[:500]
        log(f"JSON decode error: {e}; payload preview: {preview}")
        return 1

    session, pane = get_tmux_info()
    if not session:
        log("Not in tmux, exiting")
        return 0

    event_type = extract_event_type(notification)
    log(f"Event type: {event_type}")

    codex_pid = get_codex_pid() or os.getppid()

    if event_type in WAITING_EVENT_TYPES:
        update_state(codex_pid, session, pane, "waiting")
    elif event_type in WORKING_EVENT_TYPES:
        update_state(codex_pid, session, pane, "working")
    else:
        log("Event type not handled; no state update")

    return 0


if __name__ == "__main__":
    sys.exit(main())
